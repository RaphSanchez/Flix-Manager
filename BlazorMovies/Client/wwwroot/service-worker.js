// In development, always fetch from the network and do not enable offline 
// support. This is because caching would make development more difficult 
// (changes would not be reflected on the first load after each change).
//self.addEventListener('fetch', () => { });

/* Caution! Be sure you understand the caveats before publishing an application
 * with offline support. See https://aka.ms/blazor-offline-considerations
 *
 * The built-in service-worker.published.js service worker resolves requests
 * using a cache-first strategy. It prefers to return cached content,
 * regardless of whether the user has network access or newer content is
 * available on the server.
 * https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-7.0&tabs=visual-studio#cache-first-fetch-strategy
 * https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API
 * ***************************************************************************/

// In a service worker file, 'self' references the service worker itself.
// https://codelabs.developers.google.com/codelabs/push-notifications#6

// All static assets the app requires to function offline are registered in:
// Application/Server-Api/bin/Release/net7.0/publish/wwwroot
// service-worker-assets.js The resource list ("assetsManifest") is loaded by
// the service worker to identify which resources to cache.
// https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-7.0&tabs=visual-studio#background-updates
// Episode 146 of Udemy course "Programando en Blazor - ASP.Net Core 7".
self.importScripts('./service-worker-assets.js');

// Adds event listeners. Every time an "install", "activate", or "fetch"
// request is generated by our application, the "onInstall", "onActivate",
// or "onFetch" functions are invoked.
self.addEventListener('install', event => event.waitUntil(onInstall(event)));
self.addEventListener('activate', event => event.waitUntil(onActivate(event)));
// Every time an Http request is generated by our application, the onFetch
// method will execute.
self.addEventListener('fetch', event => event.respondWith(onFetch(event)));

// Handles web push event notifications; i.e., it displays the notification.
// Episode "155. Push API - Frontend" of Udemy course "Programando en Blazor -
// ASP.Net Core 7" by Felipe Gavilán.
// https://www.udemy.com/share/101ZK23@FANmoorSU4LFMMF-HqdfmMqgOZs1QMFKlYNrfLSMmADDv93Cwm23biDsFKltTxUU/
// https://github.com/dotnet-presentations/blazor-workshop/blob/main/docs/09-progressive-web-app.md#displaying-notifications
self.addEventListener('push', event => {
    // Parses 'push' event data as JSON; e.g., an object, an array, a string,
    // a number, etc.
    //
    // It parses the JSON object (payload) sent from the
    // SendNotificationMovieOnTheatersAsync method of the
    // Application/Server-Api/Helpers IPushNotificationService.
    // https://developer.mozilla.org/en-US/docs/Web/API/PushMessageData/json
    const payload = event.data.json();

    // Shows the notification and tells the event dispatcher that work is
    // ongoing; e.g., a notification awaits for the application user to click
    // on it.
    // https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification
    // https://codelabs.developers.google.com/codelabs/push-notifications#6
    // Episode 29. "Display Notifications - Progressive Web App Training" of
    // YouTube course "Progressive Web App Training" by Google Chrome Developers.
    // https://youtu.be/DMStZnU1pPc
    //
    // The JSON object's (payload) property names must be exactly the same as
    // the ones assigned to the 'payload' JSON string in the
    // SendPushMessageMovieOnTheatersAsync method of the
    // Application/Server-Api/Helpers IPushNotificationsService.
    //
    // The showNotification parameters can be:
    // https://developer.mozilla.org/en-US/docs/Web/API/Notification/Notification
    event.waitUntil(
        self.registration.showNotification('New Movie in Theaters!',
            {
                icon: 'icon-192.png',
                body: payload.title,
                image: payload.image,
                // 'data' property of the Notification interface encapsulates
                // any arbitrary data that should be passed when the
                // notification is clicked. In our example, it passes a 'url'
                // property which is used by the 'notificationclick' event
                // handler below.
                data: { url: payload.url },
                // 'requireInteraction' property of the Notification interface
                // returns a boolean value indicating that a notification
                // should remain active until the user clicks or dismisses it,
                // rather than closing automatically.
                requireInteraction: true
            })
    );
});

// Web push notification click event handler.
// Episode "155. Push API - Frontend" of Udemy course "Programando en Blazor -
// ASP.Net Core 7" by Felipe Gavilán.
// https://www.udemy.com/share/101ZK23@FANmoorSU4LFMMF-HqdfmMqgOZs1QMFKlYNrfLSMmADDv93Cwm23biDsFKltTxUU/
// https://github.com/dotnet-presentations/blazor-workshop/blob/main/docs/09-progressive-web-app.md#handling-clicks-on-notifications
// https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/notificationclick_event
// https://codelabs.developers.google.com/codelabs/push-notifications#7
self.addEventListener('notificationclick', event => {
    event.notification.close();
    // Creates a new top level browsing context and loads a given URL.
    // https://developer.mozilla.org/en-US/docs/Web/API/Clients/openWindow
    event.waitUntil(clients.openWindow(event.notification.data.url));
});

// Uses file extensions to control the offline assets to install by the
// service worker. Adds a prefix for cache versioning.
const cacheNamePrefix = 'offline-cache-';

// Defines and updates the name for the latest local repository store (cache)
// responsible for storing the static assets of the application.
const cacheName = `${cacheNamePrefix}${self.assetsManifest.version}`;

// Custom local repository stores (caches) assets for our "GET" Http requests
// for Server-Api resources. These include objects such as JSON or images. Code
// logic in "onFetch" function below. Episode 148. Guardando los resultados de
// peticiones "GET" en cache from Udemy course "Programando en Blazor - ASP.Net
// Core 7" by Felipe Gavilán.
const cacheNameDynamic = 'dynamic-cache';

// Final version for offlineAssetsInclude constant does not include file
// extensions for images; e.g., /\.png$/, /\.jpe?g$/, /\.gif$/, /\.ico$/.
//
// Service worker onInstall event handler excludes any image related files from
// the initial loading to 'offline-cache' during installation of the service
// worker. This greatly reduces initial loading times for application users
// because the application has many, many images and first service-worker
// install was taking to long.
//
// Excluding image related file extensions here only excludes loading the files
// to the 'offline-cache' during initial service worker install. Later, if the
// application user visits the 'page' and the application is online, our custom
// getResponseAndUpdateCache function loads the image files to the
// 'dynamic-cache' for later use.
//
// To have images available offline, application user must visit the 'page' at
// least once to allow our 'dynamic-cache' to store the static assets required.
//
// Regular expression patterns:
//https://www3.ntu.edu.sg/home/ehchua/programming/howto/Regexe.html#zz-1.11
// const offlineAssetsInclude = [/\.dll$/, /\.pdb$/, /\.wasm/, /\.html/, /\.js$/, /\.json$/, /\.css$/, /\.woff$/, /\.png$/, /\.jpe?g$/, /\.gif$/, /\.ico$/, /\.blat$/, /\.dat$/];
const offlineAssetsInclude = [/\.dll$/, /\.pdb$/, /\.wasm/, /\.html/, /\.js$/, /\.json$/, /\.css$/, /\.woff$/, /\.ico$/, /\.blat$/, /\.dat$/];
const offlineAssetsExclude = [/^service-worker\.js$/];

// On service worker install. By default, PWAs have support for running
// offline. A user must first visit the app while online. The browser
// automatically downloads and caches all of the (static) resources required
// to operate offline.
// https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-7.0&tabs=visual-studio#offline-support
// Episode 146. Examinando la Plantilla de PWA of Udemy course Programando en Blazor
// - ASP.Net Core 7 by Felipe Gavilán.
// https://www.udemy.com/share/101ZK23@zyFk5vpywxfFCeRMJXgCZU3-9L26cqo3j7ZhCH8cjYJdxenwl9nfOM60rs3KwqMb/
async function onInstall(event) {
    console.info('Service worker: Install');

    // Fetch and cache all matching items from the assets manifest.
    const assetsRequests = self.assetsManifest.assets
        .filter(asset => offlineAssetsInclude.some(pattern => pattern.test(asset.url)))
        .filter(asset => !offlineAssetsExclude.some(pattern => pattern.test(asset.url)))
        .map(asset => new Request(asset.url, { integrity: asset.hash, cache: 'no-cache' }));

    // Also cache authentication configuration. Example obtained creating an
    // independent hosted Blazor WASM solution with "Individual Accounts" and
    // "Progressive Web App" options checked.
    assetsRequests.push(new Request('_configuration/BlazorMovies.Client'));

    // Opens the specified cache and adds the assetRequests produced a couple
    // lines earlier.
    await caches.open(cacheName).then(cache => cache.addAll(assetsRequests));
}

// Each time the user visits the app, the browser re-requests
// service-worker.js and service-worker-assets.js in the background. The
// files are compared byte-for-byte with the existing installed service worker.
// If the server returns changed content for either of these files, the
// service worker attempts to install a new version of itself and the
// onInstall function is invoked again to fetch and cache all matching items
// from the assets manifest.
// https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-7.0&tabs=visual-studio#background-updates
// Episode 146. Examinando la Plantilla de PWA of Udemy course Programando en Blazor
// - ASP.Net Core 7 by Felipe Gavilán.
// https://www.udemy.com/share/101ZK23@zyFk5vpywxfFCeRMJXgCZU3-9L26cqo3j7ZhCH8cjYJdxenwl9nfOM60rs3KwqMb/
async function onActivate(event) {
    console.info('Service worker: Activate');

    // Delete unused caches (stale versions of the cache).
    const cacheKeys = await caches.keys();
    await Promise.all(cacheKeys
        .filter(key => key.startsWith(cacheNamePrefix) && key !== cacheName)
        .map(key => caches.delete(key)));
}

// Every time an Http request is generated from our application, the service
// worker first tries to serve cached content when available. If no content
// cache found for a certain URL (e.g., data resource from a backend API), the
// service worker falls back on a regular network request that will succeed
// only if the server is reachable.
// https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-7.0&tabs=visual-studio#how-requests-are-resolved
// Episode 146. Examinando la Plantilla de PWA and Episode 148. Guardando los
// resultados de peticiones GET en Cache of Udemy course Programando en
// Blazor - ASP.Net Core 7 by Felipe Gavilán.
// https://www.udemy.com/share/101ZK23@zyFk5vpywxfFCeRMJXgCZU3-9L26cqo3j7ZhCH8cjYJdxenwl9nfOM60rs3KwqMb/
async function onFetch(event) {

    // Custom conditional. If Http request is not "GET", fetch or process the
    // request to the server (as opposed to fetch from cache). Episode 148.
    // Guardando los resultados de peticiones "GET" en cache from Udemy course
    // "Programando en Blazor - ASP.Net Core 7" by Felipe Gavilán.
    if (event.request.method !== 'GET') {
        return fetch(event.request);
    }

    let cachedResponse = null;

    // For all navigation requests, try to serve index.html from cache.
    // If you need some URLs to be server-rendered, edit the following
    // check to exclude those URLs. E.g., all URLs containing /Identity
    // need to be handled as regular online-only requests to the server.
    // https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-7.0&tabs=visual-studio#support-server-rendered-pages
    // This line of code was replaced by the ones right below.
    /*const shouldServeIndexHtml = event.request.mode === 'navigate';*/

    // Supports server-rendered pages. Note that the signin-google and
    // signin-facebook segments don't end with a forward slash because
    // in the Http request URL, the segment is followed by a query string
    //delimiter ('?').
    // https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-7.0&tabs=visual-studio#support-server-rendered-pages
    // https://chrissainty.com/introduction-to-routing-in-blazor/
    // https://web.dev/handling-navigation-requests/#:~:text=Navigation%20requests%20are%20requests%20for,you%20to%20a%20new%20URL
    const shouldServeIndexHtml = event.request.mode === 'navigate' &&
        !event.request.url.includes('/connect/') &&
        !event.request.url.includes('/Identity/') &&
        !event.request.url.includes('/signin-google') &&
        !event.request.url.includes('/signin-facebook');

    const request = shouldServeIndexHtml ? 'index.html' : event.request;
    const cache = await caches.open(cacheName);
    cachedResponse = await cache.match(request);

    // Custom conditional. If data requested is in the offline-cache defined
    // earlier for static assets (cachedResponse is not null), return the
    // cached response.
    if (cachedResponse) {
        return cachedResponse;
    }

    // Service worker resolves requests using a cache-first strategy. It
    // prefers to return cached content regardless of whether the user
    // has network access or newer content is available on the server.
    // https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-7.0&tabs=visual-studio#cache-first-fetch-strategy
    //
    // If cachedResponse is null, "fetch(event.request)" which means process
    // the Http request and send it to the web server.
    //
    // Original .Net return was replaced by our custom code logic below.
    /*return cachedResponse || fetch(event.request);*/

    // If data requested is not in cache (offline-cache); i.e., if
    // cachedResponse is null, use our custom method to process the Http
    // request to the web server. If successful, store response in our custom
    // cache ('dynamic-cache') defined earlier to store responses from Http
    // web requests for server-API resources. Otherwise, attempt to return
    // the response from the data currently stored in dynamic-cache.
    var response = await getResponseAndUpdateCache(event);

    // return Http response.
    return response;
}

// Custom method attempts to execute an Http request to the web server and if
// successful, it will be stored in our custom cache ('dynamic-cache') defined
// earlier. If unsuccessful, it will attempt to return the response from the
// latest data previously stored in our custom dynamic cache.
//
// If successful, it is likely that the application is online. Otherwise,
// attempt to return the response from the existing cache. Episode 148.
// Guardando los resultados de peticiones "GET" en cache from Udemy course
// "Programando en Blazor - ASP.Net Core 7" by Felipe Gavilán.
async function getResponseAndUpdateCache(event) {
    try {
        // Attempt to send the Http request. If not online or no connection to
        // the web server, it will throw an exception which is handled in the
        // catch block. Otherwise, the response will be cloned and stored into
        // our custom 'dynamic-cache' defined earlier.
        const response = await fetch(event.request);

        // If a connection is established and Http request is successful,
        // check the content type of the response to ensure that it is not
        // HTML content. HTML content was handled previously with the
        // "offline-cache" which uses file extensions "offlineAssetsInclude"
        // to control the offline assets to install by the service worker.
        // "offlineAssetsInclude" includes file extension .html
        //
        // getResponseAndUpdateCache method only deals with Http requests for
        // Server-Api resources; i.e., only deals with GET, POST, PUT, DELETE
        // operations and only stores images, JSONs, etc. in cache.
        let storeInCache = true;
        const contentType = response.headers.get('content-type');

        // Ensure web server responded with the 'content type'. If so,
        // storeInCache bool value is dependent on whether the response
        // content-type includes 'text/html'.
        //
        // The FlixManager/ResetData method targets
        // MoviesController/ResetDatabaseTask endpoint which is decorated with
        // an HTTP GET verb but we do NOT want to store the response in our
        // custom 'dynamic-cache' because it is imperative to have a valid
        // connection to the web server to perform as expected.
        //
        // Including the 'get-public-key' route segment forces the
        // subscribeUserToPushNotifications and
        // unsubscribeUserFromPushNotifications functions in the
        // push-notification.js file to always fetch the Http request to the
        // server. The route segment is defined in the GetVapidPublicKeyTask
        // action of the PushSubscriptions controller.
        //
        // We need to exclude its Http response from our custom 'dynamic cache'
        // because we use it to test if the application is online. If not, it
        // throws a JSException which is handled in the
        // Application/Client/Shared PushNotification component.
        if (contentType) {
            storeInCache = !contentType.includes('text/html')
                && !event.request.url.includes('reset-db')
                && !event.request.url.includes('get-public-key');
        }

        // If storeInCache is true; i.e., if content-type is not HTML, clone
        // response and store it with its Http request URL (event.request) in
        // our custom 'dynamic-cache'. Response is stored in a (Key, Value)
        // pair format where the key is the URL of the Http request and the
        // Value is the Http response content.
        //
        // "put()" will overwrite any key/value pair previously stored in the
        // cache that matches the request.
        // https://developer.mozilla.org/en-US/docs/Web/API/Cache/put
        if (storeInCache) {
            const cache = await caches.open(cacheNameDynamic);
            await cache.put(event.request, response.clone());
        }

        // Return Http response after cloning and storing it in our custom
        // 'dynamic-cache'.
        return response;
    }
    catch (e) {
        // If no connection with the web server was established, open our
        // custom 'dynamic-cache' to attempt to generate the response from the
        // latest cache content.
        const cache = await caches.open(cacheNameDynamic);
        return cache.match(event.request);
    }
}
