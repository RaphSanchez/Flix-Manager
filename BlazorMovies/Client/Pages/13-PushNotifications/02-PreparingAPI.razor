@page "/02-push-api"

<PageTitle>Push Notifications - API</PageTitle>

<h2>Web Push Notifications - Preparing the API</h2>
<p>
    As explained in last lesson, at the very beginning of the process, a new
    <a href="https://w3c.github.io/push-api/#push-subscription">push subscription</a>
    to the web push service must be created, for a specific application user, by the
    user agent (web browser) if and when an authorization to do so is granted by the
    application user.
</p>
<p>
    The application server voluntarily identifies itself to a push service using
    VAPID. The "vapid" authentication scheme allows a client to include its identity
    in a signed token with requests that it makes. The signature can be used by
    the push service to attribute requests that are made by the application server.
</p>
<p>
    Upon successful subscription of an application user to a web push service
    resource, a response with a <code>StatusCodes.StatusCode201 Created</code> is
    received. The response payload includes the <a href="https://w3c.github.io/push-api/#push-subscription">
        push subscription
    </a> details:
</p>
<ul>
    <li>
        <p>
            <em>PushSubscription.Endpoint</em>: The absolute URL exposed by the
            push service where the application server can send push messages to.
        </p>
        <p>
            A push endpoint must uniquely identify the push subscription for a specific
            application user.
        </p>
    </li>
    <li>
        <p>
            A P-256 elliptic curve Diffie-Hellman (ECDH) public key.
        </p>
    </li>
    <li>
        <p>
            An authentication secret that the Application/Server-Api can use to
            encrypt and authenticate push messages.
        </p>
    </li>
</ul>
<figure class="figure d-flex flex-column justify-content-center">
    <img class="image-lesson" style="max-width: 550px; margin: auto;"
         src="Images/46-push-intro/04-push-subscription-response.png"
         alt="Push subscription information." />
    <figcaption class="figure-caption text-center">
        <a href="https://blog.mozilla.org/services/2016/08/23/sending-vapid-identified-webpush-notifications-via-mozillas-push-service/#receive">
            Sending VAPID identified WebPush Notifications via Mozilla's Push Service.
        </a>
    </figcaption>
</figure>
<p>
    Where the domain of the endpoint is essentially the push service. The path
    of the endpoint is client identifier information that helps the push
    service determine exactly which client (application user) to push the message
    to. The <em>keys</em> are used for encryption.
</p>
<p>
    The subscription details are then distributed to the application server
    (Application/Server-Api) who is responsible for persisting the data into the
    database table. <strong>
        The push subscription is the basis of all future interactions between the
        three basic actors:
    </strong>
</p>
<ol>
    <li>The Application/Server-Api.</li>
    <li>A push service.</li>
    <li>A user agent.</li>
</ol>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/02-push-overview-subscription.svg"
         alt="Push subscription flow." />
</div>
<h4>VAPID Keys</h4>
<p>
    We need to generate the VAPID keys that our Application/Server-Api will use to
    voluntarily identify itself to a push service with a signed token that includes
    its identity. This signature is used by the push service to attribute requests
    to our application.
</p>
<p>
    <span class="badge bg-primary">Task:</span>
    Generate the VAPID keys and use the <a>secret-manager tool</a> to manage them
    without making them available in source code because this is sensitive data that
    can be used to send push notifications to our application.
</p>
<p>
    There are several VAPID key generators available online such as <a href="https://vapidkeys.com/">
        https://vapidkeys.com
    </a> or Google Chrome's <a href="https://web-push-codelab.glitch.me/">
        Push Companion
    </a> which generate the keys and deliver them in a JSON object format that contains
    a public key, a private key, and optionally the email to which the push service can
    send any info regarding unexpected errors.
</p>
<p>
    <span class="badge bg-dark">Step One:</span>
    Go to <a href="https://vapidkeys.com">https://vapidkeys.com</a> to generate the keys
    for your application:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/03-vapid-json.png"
         alt="VAPID keys in json format." />
</div>
<p>
    <span class="badge bg-dark">Step Two:</span>
    Use the <a href="https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&tabs=windows">
        secret manager tool
    </a> to safely store the VAPID keys during the development stage. Later, we will use
    Azure key vault to secure these secrets in production.
</p>
<p>
    In case you haven't done so, you must <a href="https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&tabs=windows#enable-secret-storage">
        enable secret storage
    </a> in the project (Application/Server-Api). If you have followed the previous lectures,
    you might recall that we enabled it in the <a href="08-account-confirmation">
        Account Confirmation
    </a> lesson of the Security module.
</p>
<p>
    <span class="badge bg-dark bg-opacity-50">2.1:</span>
    Go to Visual Studio Solution Explorer, right click the Application/Server-Api project and
    select "Open Terminal" to open a developer PowerShell. Use the terminal to set the
    VAPID keys obtained earlier with the secret manager tool using the following command:
    <strong><code>dotnet user-secrets set VapidEmail "&lt;your-email&gt;" </code></strong>:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/05-secure-vapid-email.png"
         alt="Developer power shell." />
</div>
<p>
    <span class="badge bg-dark bg-opacity-50">2.2:</span>
    Repeat the process with the VapidPublicKey and VapidPrivateKey. Then go to Visual Studio
    Explorer, right-click the Application/Server-Api project and select "Manage User Secrets"
    to view the file contents:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/06-secrets.png"
         alt="Application secrets file." />
</div>
<p>
    <span class="badge bg-dark">Step Three:</span>
    Use the <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-6.0">
        options pattern
    </a> to bind the VAPID keys stored in the application secrets with a class named
    VapidOptions that will be responsible for securely fetching the VAPID keys during
    development.
</p>
<p>
    <span class="badge bg-dark bg-opacity-50">3.1:</span>
    Go to the Application/Server-Api/Helpers directory and create a class named
    VapidOptions that will be the binding medium for securely fetching the
    VAPID keys from the application secrets:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/07-vapid-options.png"
         alt="VapidOptions class." />
</div>
<p>
    <span class="badge bg-dark bg-opacity-50">3.2:</span>
    Add the PushNotificationOptions type to the dependency injection container of the
    Application/Server-Api project:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/08-di-container.png"
         alt="DI container of Application/Server-Api." />
</div>
<p>
    The VAPID details are stored in a secure location and ready to be fetched safely
    during the development stage of the application. We can now focus our attention
    to define the code logic for the required functionality.
</p>
<p>Data Sources:</p>
<ul>
    <li>
        <a href="https://w3c.github.io/push-api/#push-subscription">
            Push API W3C Editor's Draft
        </a>
    </li>
    <li>
        <a href="https://vapidkeys.com">
            VapidKeys.com
        </a>
    </li>
    <li>
        <a href="https://blog.mozilla.org/services/2016/08/23/sending-vapid-identified-webpush-notifications-via-mozillas-push-service/">
            Sending VAPID identified WebPush Notifications via Mozilla's Push Service
        </a>
    </li>
    <li>
        <a href="https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&tabs=windows">
            Safe storage of app secrets in development in ASP.Net Core
        </a>
    </li>
    <li>
        <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-6.0">
            Options pattern in ASP.Net Core
        </a>
    </li>
</ul>
<h4>Preparing the Server-Api</h4>
<p>
    From the backend perspective, the Application/Server-Api is responsible for:
</p>
<ol>
    <li>
        <p>
            Fetching the VAPID public key to perform operations with the push
            service such as subscribe/unsubscribe an application user and
            send push notifications.
        </p>
    </li>
    <li>
        <p>
            Persist into the database the push subscription data provided by the
            user agent (web browser) for each application user that is subscribed
            to the push service to receive push notifications.
        </p>
    </li>
    <li>
        <p>
            Remove from the database the push subscription data of a specific user
            that is unsubscribed from the push service to receive push notifications.
        </p>
    </li>
</ol>
<p>
    To add any given functionality for the data entity type that will represent the
    details of a unique push subscription to the web push service for a specific
    application user (PushSubscriptionDetails), we must prepare the
    Application/Server-Api to have the capability of handling it. Examine our push
    notification system diagram:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/03-push-notif-syst-api-embedded.svg"
         alt="Push notification system diagram." />
</div>
<p>
    As mentioned in the "Building a web API" section of the <a href="05-api">Server-Api</a>
    lesson:
</p>
<ul>
    <li>
        Web APIs are responsible for handling Application/Client requests to receive,
        send, or modify data stored in the database (push subscription data for specific
        users in this case).
    </li>
    <li>
        The application architecture uses the repository pattern for Create, Read, Update,
        and Delete (CRUD) operations.
    </li>
    <li>
        The application architecture includes the unit of work pattern to coordinate the
        work of multiple repositories using a single (unique) database context instance
        during a business transaction.
    </li>
    <li>
        The abstract representations (interfaces) for the repositories, the unit of
        work, and the API services (serialization/deserialization) are located in the
        Application/Client.
    </li>
    <li>
        The implementations (concrete classes) for the repositories, the unit of work,
        and the data store are located in the Application/Server-Api.
    </li>
    <li>
        The Application/Client employs an abstract layer (IApiService) responsible for
        exposing the available operations and for hiding the details of how to invoke
        Application/Server-Api endpoints.
    </li>
    <li>
        The IApiService in turn establishes a contract for exposing one IEntityName
        interface, in the form of a read-only property, for each data entity mapped
        to the data store. These IEntityName interfaces are the entry point for
        the IUnitOfWork responsible for exposing the business logic (functionality):
    </li>
</ul>
<div class="image-lesson mb-3">
    <img src="Images/08-ServerApi/00-application-diagram.svg"
         alt="Application flow diagram." />
</div>
<p>
    The Application/Client makes a data request, the IApiService serializes the data and
    sends the Http request to the Application/Server-Api/Controllers using the appropriate
    IEntityName interface as the entry point.
</p>
<p>
    The Application/Server-Api controller employs the Application/Server-Api/IUnitOfWork
    business logic methods to query the database through the
    Application/Server-Api/DataStore/DbContext and, if necessary, persist any changes made
    to in-memory objects. When the request is completed, the process is reversed, and the
    response is sent back to the client.
</p>
<p>
    Both abstract layers (IApiService and IUnitOfWork) adhere to the repository and the unit
    of work patterns to expose to the Application/Client their higher level interfaces and
    hide the actual implementation (code logic).
</p>
<p>
    The operations exposed to the client (by the <strong>IApiService</strong>) mirror
    (same signature) the operations executed through the <strong>IUnitOfWork</strong>
    (business logic and database operations). For this reason, <strong>both</strong>
    abstract layers <strong>employ IEntityName interfaces</strong> to expose and
    represent data entities which in turn implement an IRepository&lt;TEntity&gt;
    interface which establishes the contract for the required general functionality
    applicable to all data entities.
</p>
<p>
    IEntityName interfaces not only implement IRepository&lt;TEntity&gt;, they also extend
    its functionality with operations (code logic) that are specific to the entity type they
    represent. <strong>
        IEntityName interfaces are exposed, and implemented in their own way,
        by the IApiService
    </strong> (serialize/deserialize and map to controller endpoints) <strong>
        and the IUnitOfWork interface
    </strong> (business logic and data base persistence).
</p>
<p>
    In other words, the procedure we will follow to prepare the web server-API to
    have the capability of handling a new data entity type (PushSubscriptionDetails) and
    perform the operations to get the VAPID public key, add, and/or delete the push
    subscription data of any given application user is:
</p>
<ul>
    <li>
        <p>
            Add a new PushSubscriptionDetails root entity type to the <a href="06-api-db-support">
                database schema
            </a>.
        </p>
    </li>
    <li>
        <p>
            Incorporate the PushSubscriptionDetails data entity type to the <a href="07-api-respository">
                repository pattern
            </a>.
        </p>
    </li>
    <li>
        <p>
            Incorporate the PushSubscriptionDetails entity type to the <a href="07-api-repository">
                unit of work pattern
            </a>.
        </p>
    </li>
    <li>
        <p>
            Scaffold a PushSubscriptions <a href="08-api-controllers">controller</a>
            which will define the REST-Api <em>actions</em> that invoke CRUD operations
            (business logic) to create, read, update, and delete push subscriptions
            related data to/from the database.
        </p>
    </li>
    <li>
        <p>
            Incorporate the PushSubscriptionDetails entity type to the <a href="09-api-connector-service">
                IApiService
            </a> which acts as an intermediary between the Application/Client and the
            Application/Server-Api. Handles Http requests/responses and serializes/deserializes
            the data.
        </p>
    </li>
</ul>
<p>
    <span class="badge bg-primary">Task:</span>
    Prepare the web server-API to have the capability of handling a new data entity type
    (PushSubscriptionDetails) and perform the operations to get the VAPID public key, add,
    and/or delete the push subscription details of any given application user.
</p>
<p>
    <span class="badge bg-dark">Step One:</span>
    Add a new PushSubscriptionDetails root entity type to the database schema. This is the
    type that will represent the push subscription data provided by a push service upon
    successful subscription of a specific application user to the push notifications service.
</p>
<div class="alert alert-warning mx-3" role="alert">
    <p style="margin: 0; padding: 0; color: rgb(71, 68, 68); font-size: .90rem">
        As explained in the "Entities, Models, Data Transfer Objects (DTOs), and
        Mapping" section of the <a href="">Forms Part-II</a> lesson, <strong>
            a web API should not expose database entities to the client.
        </strong> Nevertheless, for simplicity, we will omit this step.
    </p>
</div>
<p>
    <span class="badge bg-dark bg-opacity-50">1.1:</span>
    Go to the Application/Shared/EDM directory to add the PushSubscriptionDetails root
    entity:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/09-push-subs-details-one.png"
         alt="PushSubscriptionDetails part one." />
    <img src="Images/46-push-intro/10-push-subs-details-two.png"
         alt="PushSubscriptionDetails part two." />
</div>
<p>
    <span class="badge bg-dark bg-opacity-50">1.2:</span>
    Update the <a href="06-api-db-support">database context model</a> to include the recently
    created PushSubscriptionDetails data entity.
</p>
<p>
    Go to the <em>Package Manager Console</em>, confirm that the project selected in the
    "Default Project" dropdown is the project where the database context model resides (e.g.,
    BlazorMovies.Server) and execute the <code>update-database</code> command to ensure there
    are no pending database operations before making any modifications and/or additions to it.
</p>
<p>
    Go to the Application/Server-Api/DataStore AppDbContext database context model and
    expose the PushSubscriptionDetails root entity as a DbSet&lt;TEntity&gt; property which
    represents in-memory objects mapped to the corresponding database table:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/11-app-db-context.png"
         alt="AppDbContext with PushSubscriptionDetails DbSet." />
</div>
<p>
    Go to the <em>Package Manager Console</em>, confirm that the project selected in the
    "Default Project" dropdown is the project where the database context model resides
    (e.g., BlazorMovies.Server) and execute the following commands:
</p>
<ol>
    <li>
        <p>
            <code>Add-Migration PushSubscriptionsDetails</code> and check the code in the
            'migration file' to make sure that everything will be created as expected.
        </p>
    </li>
    <li>
        <p>
            <code>Update-Database</code> to update the database schema.
        </p>
    </li>
</ol>
<p>
    Folder tree of the database context model with the AppDbContext class and a directory
    where each additional migration is stored with a chronological time stamp in its name:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/12-data-store-folder-tree.png"
         alt="Folder tree." />
</div>
<p>
    The Package Manager Console informs a success state on building the migration; i.e.,
    in building the code with the operations that will be executed on the database:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/13-push-subscription-details-migration.png"
         alt="PushSubscriptionDetails migration file." />
</div>
<p>
    Update-Database and confirm that the database table is created in the MoviesDB
    database.
</p>
<div class="alert alert-info mx-3" role="alert">
    <p style="margin: 0; padding: 0; color: rgb(71, 68, 68); font-size: .90rem">
        If you encounter an error somewhere along the lines of <em>
            "There is already an object named <code>AspNetRoles</code> in the database ..."
        </em>, you have to drop the database. However, you can use SQL Server Management
        Studio to back up the data before dropping the database. Database --> Task -->
        Generate Scripts --> "Set Scripting Options" window --> Types of data to script
        --> Data Only. You can refer to
        <a href="https://stackoverflow.com/questions/55562371/ef-core-there-is-already-an-object-named-aspnetroles-in-the-database">
            EF Core There is already an object named 'AspNetRoles' in the database
        </a> for more info.
    </p>
</div>
<p>
    Our PushSubscriptionsDetails root entity does not have any relationships with other
    data entities and does not require any special configurations. Therefore, we will
    not create an <em>Application/Server-Api/DataStore/EntityConfigurations</em>
    PushSubscriptionDetailsConfiguration file as demonstrated in the <a href="06-api-db-support">
        DbSupport
    </a> lesson.
</p>
<p>
    <span class="badge bg-dark">Step Two:</span>
    Incorporate the PushSubscriptionDetails data entity type to the <a href="07-api-respository">
        repository pattern
    </a>.
</p>
<p>
    The repository pattern is responsible for encapsulating the business logic of the
    application. It operates as an intermediary between the Application/Server-Api/UnitOfWork
    and the Application/Server-Api/DataStore (database).
</p>
<p>
    <span class="badge bg-dark bg-opacity-50">2.1:</span>
    Go to the Application/Client/ApiServices/IRepositories directory and add an
    IEntityName interface (IPushSubscriptions). Include the
    AddPushSubscriptionAsync, DeletePushSubscriptionAsync, and
    GetVapidPublicKeyAsync() methods:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/14-i-push-subscriptions-details-one.png"
         alt="IPushSubscriptions interface part one." />
    <img src="Images/46-push-intro/15-i-push-subscriptions-details-two.png"
         alt="IPushSubscriptions interface part two." />
</div>
<p>
    The IPushSubscriptions interface establishes a contract for entity specific
    methods; i.e., for any methods that do not fit in the IRepository&lt;TEntity&gt;
    generic interface that it implements. Any class that intends to implement this
    interface must honor the 'contract'.
</p>
<p>
    <span class="badge bg-info">Notice:</span>
    Application/Server-Api POST and DELETE operations are typically designed to expect
    the authorize/authenticate JWTs to authorize, or not, the current application user
    based on its credentials.
</p>
<p>
    Nevertheless, the ability to subscribe/unsubscribe from the push service will be
    made available to all users. For this reason, the implementations of the methods
    will be designed to work with an Http Client that does not include the security JWT
    in the request. You can refer to <a href="06-security-protect-api">
        Secure API
    </a> and <a href="07-policy-based-authz">
        Policy-based AuthZ
    </a> lessons for more info.
</p>
<p>
    <span class="badge bg-info">Notice:</span>
    The instructor employs a minimal API to fetch the VapidPublicKey. You can refer
    to "Episode 154. Push API - Backend" of Udemy course <a href="https://www.udemy.com/share/101ZK23@FHXR8HROjz7zUmlmb0LdPBR7qBb3ffpRwyKadwoOp833xq3Gp8pRfnTVDJ6xaO9s/">
        Programando en Blazor - ASP.Net Core 7
    </a> by Felipe Gavilán and <a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-7.0">
        Tutorial: Create a minimal API with ASP.Net Core
    </a> for more info.
</p>
<p>
    <span class="badge bg-dark bg-opacity-50">2.2:</span>
    Go to the Application/Server-Api/Repositories directory and add an
    EfEntityName class (EfPushSubscriptions). It should derive from the generic
    EfRepository&lt;TEntity&gt; class to inherit the implementation of the general
    functionality that is applicable to any entity type.
</p>
<p>
    Additionally, each EfEntityName class (e.g., EfPushSubscriptionDetails) must
    implement the entity specific functionality defined in its corresponding IEntityName
    interface (e.g., IPushSubscriptions); i.e., any methods that do not fit in the
    EfRepository&lt;TEntity&gt; class:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/16-ef-push-subscription-details-one.png"
         alt="EfPushSubscription repository part one." />
    <img src="Images/46-push-intro/17-ef-push-subscription-details-two.png"
         alt="EfPushSubscription repository part two." />
    <img src="Images/46-push-intro/18-ef-push-subscription-details-three.png"
         alt="EfPushSubscription repository part three." />
    <img src="Images/46-push-intro/19-ef-push-subscription-details-four.png"
         alt="EfPushSubscription repository part four." />
</div>
<p>
    <span class="badge bg-info">Notice:</span>
    It includes a constructor injection of the built-in <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-6.0#options-interfaces">
        IOptions&lt;TOptions&gt;
    </a>
    interface to enable access to the Application/Server-Api/Helpers VapidOptions class
    that provides access to the VAPID details (sensitive information) that the
    Application/Server-Api can use to identify itself with to the push service.
</p>
<p>
    <span class="badge bg-info">Notice:</span>
    Unlike the delete operations of the other repositories that use the primary key for
    retrieving an object from the database, the <em>DeletePushSubscriptionAsync</em>
    method uses two properties (P256dh and Auth) of the PushSubscriptionDetails instance.
</p>
<p>
    The reason is that the PushSubscriptionDetails instance passed from the
    Application/Client originates from the push service which uses a primary key that
    will not match the primary key of the corresponding record stored in the
    PushSubscriptionsDetails database table.
</p>
<p>
    <span class="badge bg-dark">Step Three:</span>
    Incorporate the PushSubscriptionDetails data entity type to the <a href="07-api-repository">
        unit of work pattern
    </a>.
</p>
<p>
    A unit of work keeps track of everything it is done during a business transaction
    that can affect the database. When the business transaction is completed, it figures
    out everything that needs to be done to alter the database because it maintains a
    list of objects affected as a result of the work.
</p>
<p>
    It coordinates the operations of multiple repositories (EfEntityName) by creating a
    single database context instance shared by all of them. The
    Application/Client/IUnitOfWork interface establishes a contract or protocol for
    persisting to the database any changes made to in-memory objects (DbSet&lt;T&gt;s)
    during a business transaction.
</p>
<p>
    The IUnitOfWork exposes each abstract IEntityName (e.g., IPushSubscriptions)
    and includes a <dfn>SaveAsync()</dfn> method which indicates the end of a unit of
    work (or business transaction) to initiate an update of the database.
</p>
<p>
    <span class="badge bg-dark bg-opacity-50">3.1</span>
    Go to the Application/Client/ApiServices/IRepositories IUnitOfWork interface and
    add the IPushSubscriptions interface which is a representation of the data
    entity that the Application/Server-Api/Controllers PushSubscriptionsController
    will consume to access business logic operations:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/20-i-unit-of-work-one.png"
         alt="IUnitOfWork part one." />
    <img src="Images/46-push-intro/21-i-unit-of-work-two.png"
         alt="IUnitOfWork part two." />
</div>
<p>
    <span class="badge bg-dark bg-opacity-50">3.2</span>
    Go to the Application/Server-Api/Repositories UnitOfWork class and add the
    IPushSubscriptions interface as a read-only property. Ensure it is initialized
    with a concrete instance of the type that implements the entity's functionality:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/22-unit-of-work-one.png"
         alt="UnitOfWork part one." />
    <img src="Images/46-push-intro/23-unit-of-work-two.png"
         alt="UnitOfWork part two." />
    <img src="Images/46-push-intro/24-unit-of-work-three.png"
         alt="UnitOfWork part three." />
    <img src="Images/46-push-intro/25-unit-of-work-four.png"
         alt="UnitOfWork part four." />
</div>
<p>
    <span class="badge bg-dark">Step Four:</span>
    Scaffold a PushSubscriptions <a href="08-api-controllers">controller</a>
    with the REST-Api <em>actions</em> such as GetVapidPublicKeyTask (HttpGet),
    AddPushSubscriptionDetailsTask (HttpPost), and DeletePushSubscriptionDetailsTask
    (HttpPost).
</p>
<p>
    The PushSubscriptions controller models the functionality for the
    PushNotification component UI as a set of resources where operations are
    represented by HTTP verbs. MVC controllers are responsible for responding to
    Http requests which are mapped to a particular controller endpoint (<em>action</em>).
</p>
<div class="alert alert-warning mx-3" role="alert">
    <p style="margin: 0; padding: 0; color: rgb(71, 68, 68); font-size: .90rem">
        Do <strong>not</strong> include an "Async" suffix to the name of the <em>
            action methods
        </em> because ASP.Net Core MVC trims the suffix "Async" from <em>action</em>
        names by default. This change affects both routing and link generation.
    </p>
</div>
<p>
    <span class="badge bg-dark bg-opacity-50">4.1:</span>
    Go to the Application/Server-Api/Controllers directory and scaffold a controller
    named PushSubscriptionsController. It must derive from <code>ControllerBase</code>
    and include a constructor injection of the IUnitOfWork interface:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/29-push-subs-controller-one.png"
         alt="PushSubscriptions controller part one." />
    <img src="Images/46-push-intro/30-push-subs-controller-two.png"
         alt="PushSubscriptions controller part two." />
    <img src="Images/46-push-intro/31-push-subs-controller-three.png"
         alt="PushSubscriptions controller part three." />
    <img src="Images/46-push-intro/32-push-subs-controller-four.png"
         alt="PushSubscriptions controller part four." />
    <img src="Images/46-push-intro/33-push-subs-controller-five.png"
         alt="PushSubscriptions controller part five." />
    <img src="Images/46-push-intro/34-push-subs-controller-six.png"
         alt="PushSubscriptions controller part six." />
</div>
<p>
    <span class="badge bg-warning">Notice:</span>
    Examine the following distinctions for the controller actions:
</p>
<ul>
    <li>
        <p>
            The <em>DeletePushSubscriptionDataTask</em> action is decorated with an <code>HttpPost</code>
            verb attribute as opposed to an <code>HttpDelete</code> verb attribute. The reason is that
            the <code>HttpClient.DeleteAsync(requestUri)</code> <a href="09-api-connector-service">
                resource method
            </a> invoked by the <code>IApiConnector.InvokeDeleteAsync&lt;T&gt;()</code> method in
            the Application/Client/ApiServices/ApiManager/ApiConnector class to serialize/deserialize
            the Http request/response to travel through the internet does not have an overload that
            allows passing an object value in the request body:
        </p>
        <p>
            Public interface of the HttpClient.DeleteAsync resource method:
        </p>
        <div class="image-lesson mb-3">
            <img src="Images/46-push-intro/26-delete-resource-method-one.png"
                 alt="InvokeDeleteAsync method part one." />
            <img src="Images/46-push-intro/27-delete-resource-method-two.png"
                 alt="InvokeDeleteAsync method part two." />
        </div>
        <p>
            Public interface of the HttpClient.PostAsJsonAsync resource method:
        </p>
        <div class="image-lesson mb-3">
            <img src="Images/46-push-intro/28-post-resource-method.png"
                 alt="InvokePostAsync method." />
        </div>
        <p>
            We need to pass an instance of the <code>PushSubscriptionDetails</code> to the
            <em>DeletePushSubscriptionDataTask</em> controller action because we use the
            <code>PushSubscriptionDetails.P256dh</code> and the
            <code>PushSubscriptionDetails.Auth</code> to attempt to retrieve the equivalent
            record from the database. Using the request body and delegating the <a href="08-api-controllers">
                model binding
            </a> operations to .Net is much simpler than attempting to pass the object in the
            URL and handle the binding ourselves.
        </p>
    </li>
    <li>
        <p>
            An alternative to the <em>GetVapidPublicKeyTask</em> action is to create a minimal
            API. You can refer to "Episode 154. Push API - Backend" of Udemy course <a href="https://www.udemy.com/share/101ZK23@FHXR8HROjz7zUmlmb0LdPBR7qBb3ffpRwyKadwoOp833xq3Gp8pRfnTVDJ6xaO9s/">
                Programando en Blazor - ASP.Net Core 7
            </a> by Felipe Gavilán and
            <a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-7.0">
                Tutorial: Create a minimal API with ASP.Net Core
            </a> for more info.
        </p>
    </li>
    <li>
        <p>
            The <em>action</em> methods in the PushSubscriptions controller are decorated
            with an <code>[AllowAnonymous]</code> attribute to specify that their resources do
            not require an authorization token.
        </p>
    </li>
</ul>
<p>
    At this point, we should have a fully working Application/Server-Api. It is a good idea
    to ensure that it is working as intended before incorporating the PushSubscriptionDetails
    entity type to the IApiService which acts as an intermediary between the Application/Client
    and the Application/Server-Api.
</p>
<h4>Testing the Application/Server-API</h4>
<p>
    <span class="badge bg-dark">Step Five:</span>
    Test the <em>location header</em> URI for each <a href="08-api-controllers">
        controller
    </a> action; i.e., type the "api/controllername" URI directly into the web browser's
    address bar to ensure the Api responds with an object in JSON format. For controller
    <em>actions</em> that expect data in the body of the request, you can use the
    <a href="https://www.postman.com/downloads/">
        Postman
    </a> platform.
</p>
<p>
    <span class="badge bg-dark bg-opacity-50">5.1:</span>
    Test the location header for the GetPaginatedUsersTask <em>action</em>. Its URI is
    composed with the application URL plus the route segment of the controller
    endpoint; e.g., <a href="https://localhost:7077/api/pushsubscriptionsdetails/get-public-key">
        https://localhost:7077/api/pushsubscriptionsdetails/get-public-key
    </a>. Recall that you can get or set the application's URL from the
    Application/Server-Api/Properties <em>launchsettings.json</em> file.
</p>
<p>
    <span class="badge bg-info">Notice:</span>
    Keep in mind that in "Step Ten" of the "Testing Offline Support" section in the
    <a href="02-pwa-creation">Creating a PWA</a> lesson, we modified the predefined
    <em>Application/Client/wwwroot service-worker.js</em> file to enable the PWA
    features during development. We performed a copy-paste of the content of the
    <em>service-worker.published.js</em> file (used in production) to the
    <em>service-worker.js</em> file (using in development).
</p>
<p>
    "Clean" and "Rebuild" the Application/Client project, run the application to
    a server that supports HTTPS, and access the app in a browser at its secure HTTPS
    address. PWA <em>service workers</em> do not execute in regular HTTP protocol.
</p>
<p>
    <span class="badge bg-dark bg-opacity-50">5.2:</span>
    Open the web browser's developer tools and verify that a <em>service worker</em>
    is registered for the host on the <em>Application</em> tab. Allow the latest version
    of the <em>service worker</em> to install and click "skip waiting" to activate it:
</p>
<div class="image-lesson mb-3">
    <img src="Images/42-mutator-requests/20-skip-waiting.png"
         alt="Application tab of web browser's dev tools." />
</div>
<div class="alert alert-info mx-3" role="alert">
    <p style="margin: 0; padding: 0; color: rgb(71, 68, 68); font-size: .90rem">
        If you get a Console error with something along the lines of: "Failed to
        find a valid digest in the 'integrity' attribute for resource .......",
        you can refer to the "Publish and Deploy a PWA Application" at the end of
        the <a href="02-pwa-creation">Creating a PWA</a> lesson to fix this issue.
    </p>
</div>
<p>
    We decorated the controller <em>actions</em> with an <code>[AllowAnonymous]</code>
    attribute. Therefore, logging in with a user that has full admin credentials should
    not be necessary.
</p>
<p>
    <span class="badge bg-dark bg-opacity-50">5.3:</span>
    Use the <a>Postman</a> platform to send an Http GET request:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/36-postman-public-key-response.png"
         alt="VAPID public key in Http response." />
</div>
<p>
    The VAPID public key is sent in the body of the Http response. It has been blurred for
    security reasons. What do you think would happen if we were to type the URI that points
    to the <em>GetVapidPublicKeyTask</em> action in the web browser's address bar?
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/35-nothing-address.png"
         alt="Not Found component." />
</div>
<p>
    The <code>onFetch(event)</code> event handler function of the <a href="02-pwa-creation">
        service worker
    </a> evaluates if the Http request is an HTTP GET request, as is the case of the
    GetVapidPublicKeyTask action. If so, it serves the <code>index.html</code>
    <a href="02-components-part-two">host page</a> and attempts to retrieve the response
    from the 'offline-cache' which is configured to automatically download HTML content
    among other things but not capable of storing Application/Server-Api resources:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/37-service-worker-on-fetch.png"
         alt="Service worker onFetch event handler." />
</div>
<div class="alert alert-info mx-3" role="alert">
    <p style="margin: 0; padding: 0; color: rgb(71, 68, 68); font-size: .90rem">
        This is not the final of the <code>offlineAssetsInclude</code> local reference
        in the service worker files (<em>service-worker.js</em> and
        <em>service-worker.published.js</em>). After some testing, it was determined
        that any image related files should not be loaded to the 'offline-cache' during
        initial install of service worker because the application has too many files and
        it was taking too long for the application to start. This is unacceptable. Refer
        to the "Loading Image Files to 'dynamic-cache'" section at the end of the
        <a href="04-pwa-mutator-requests">Mutator Requests</a> lecture.
    </p>
</div>
<p>
    In other words, the Http response does not contain the VAPID public key nor does it
    contain any HTML because there is no Razor routable component related to the controller
    action.
</p>
<p>
    As a result, we get a "Sorry, there's nothing at this address". The Http GET request
    sent from the Postman platform retrieves the VAPID public key because it does not send
    the request through our application; i.e., it is not going through and/or being
    intercepted by the service worker.
</p>
<p>
    You can confirm this by placing a breakpoint on the GetVapidPublicKeyTask <em>action</em>
    and sending the Http request with Postman and with the address bar of the web browser.
    The latter option will not hit the breakpoint because the request is intercepted by
    the service worker.
</p>
<p>
    Recall from the <a href="02-pwa-creationg">Creating a PWA</a> lesson of the PWAs
    module, that the service worker resolves the requests by returning the cached content
    for <em>/index.html</em> regardless of the requested URL. If the application has
    certain URLs that must return server-rendered results and not serve <em>/index.html</em>
    from the cache, you must explicitly define the route that must be excluded.
</p>
<p>
    <span class="badge bg-dark bg-opacity-50">5.4:</span>
    Temporarily force the URL to be handled as a regular online request to the server:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/38-on-fetch-exclude-get-public-key.png"
         alt="onFetch event handler excludes get-public-key route segment." />
</div>
<p>
    <span class="badge bg-dark bg-opacity-50">5.5:</span>
    "Clean" and "Rebuild" the application, install the lates version of the service worker,
    refresh the page, and type the URL to the GetVapidPublicKeyTask endpoint. This time
    you should receive the VAPID public key.
</p>
<p>
    <span class="badge bg-dark bg-opacity-50">5.6:</span>
    <span class="mark">
        <strong>
            Remove the exclusion line for the 'get-public-key' route segment.
        </strong> It is only required for testing purposes:
    </span>
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/39-remove-route-segment.png"
         alt="Route segment removed from the exclusion block." />
</div>
<h4>IApiService</h4>
<p>
    The module of the Application/Server-Api for a type <code>PushSubscriptionDetails</code>
    is configured but we are not done yet. The next step is to create a way (IApiService)
    for the Application/Client to call and consume the Application/Server-Api resources 
    related with the push notifications service:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/04-push-notif-syst-api-service-embedded.svg"
         alt="Push notification system diagram." />
</div>
<p>
    As we mentioned earlier, the Application/Client makes a data request and the IApiService
    (abstract layer) sends the HttpRequest to the Application/Server-Api/Controllers. The
    Application/Server-Api/Controllers layer employs the IUnitOfWork (abstract layer).
</p>
<p>
    The IUnitOfWork exposes the business logic methods to query the
    Application/Server-Api/DataStore database and, if necessary, persist any changes made
    to in-memory objects during a business transaction. Both abstract layers, the
    <code>IApiService</code> and the <code>IUnitOfWork</code>, establish a contract for
    exposing one <code>IEntityName</code> interface, in the form of a read-only property,
    for each data entity mapped to the database.
</p>
<p>
    In other words, both abstract layers employ a shared IEntityName interface (e.g.,
    IPushSubscriptions) to expose and represent data entities which in turn
    implement the IRepository&lt;TEntity&gt; interface which establishes a contract for
    the required general functionality applicable to all data entities.
</p>
<p>
    IEntityName interfaces are exposed, and implemented in their own way, by the IApiService
    and the IUnitOfWork interfaces. IEntityName interfaces not only implement the
    IRepository&lt;TEntity&gt;, they also extend its functionality with operations that
    are specific to the entity type they represent.
</p>
<p>
    The structure of the Application/Client/ApiServices "IApiService" that connects the
    Application/Client with the Application/Server-Api is equivalent to the
    Application/Client/ApiServices "IUnitOfWork" that connects the Application/Server-Api
    controller to the application business logic because it also implements the repository
    pattern except that <strong>
        instead of declaring the business logic, it defines the code logic to invoke web
        API endpoints and to serialize/deserialize data.
    </strong>
</p>
<p>
    The class that implements the Application/Client/ApiServices IUnitOfWork interface
    (UnitOfWork) has a constructor injected dependency to the AppDbContext that
    represents a session with the database that can be used to query and save instances.
</p>
<p>
    The class that implements the Application/Client/ApiServices IApiService interface
    (ApiService) has a constructor injected dependency to an Application/Client/ApiService
    <code>ApiConnector</code> class responsible for serializing/deserializing .Net objects
    to JSON format because it acts as an Http session to send/receive Http requests/responses.
    The ApiConnector class is also responsible for defining the <a href="08-api-controllers">
        media type
    </a> of the resource representations.
</p>
<p>
    <span>Step Six:</span>
    Incorporate the PushSubscriptionDetails entity type to the <a href="09-api-connector-service">
        IApiService
    </a> which acts as an intermediary between the Application/Client and the
    Application/Server-Api. It handles Http requests/responses and serializes/deserializes
    the data.
</p>
<p>
    <span class="badge bg-dark">6.1</span>
    Go to the Application/Client/ApiServices/ApiManager IApiService and add the
    IPushSubscriptions interface which is a representation of the data entity that
    the Application/Client can consume to invoke the Application/Server-Api controller
    endpoints to send/receive Http requests/responses safely:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/40-i-api-service.png"
         alt="IApiService interface." />
</div>
<p>
    <span class="badge bg-dark">6.2</span>
    Go to the Application/Client/ApiServices/ApiManager and add the ApiPushSubscriptions
    class which wraps the code logic to serialize/deserialize and build the URI for the
    Http requests/responses for specific functionality on an entity type. Recall that
    it implements the ApiRepository with general functionality and the
    IPushSubscriptions interface which establishes a contract for the specific
    functionality required by the PushSubscriptionDetail data entity.
</p>
<p>
    IPushSubscriptions interface is exposed, and implemented in its own way, by the
    IApiService and the IUnitOfWork interfaces. IPushSubscriptions interface not
    only implements the IRepository&lt;TEntity&gt;, it also extends its functionality
    with operations specific to the entity type it represents. For example,
    AddPushSubscriptionAsync, GetVapidPublicKeyAsync, and
    DeletePushSubscriptionAsync:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/41-api-subscriptions-one.png"
         alt="ApiSubscriptions part one." />
    <img src="Images/46-push-intro/42-api-subscriptions-two.png"
         alt="ApiSubscriptions part two." />
    <img src="Images/46-push-intro/43-api-subscriptions-three.png"
         alt="ApiSubscriptions part three." />
    <img src="Images/46-push-intro/44-api-subscriptions-four.png"
         alt="ApiSubscriptions part four." />
    <img src="Images/46-push-intro/45-api-subscriptions-five.png"
         alt="ApiSubscriptions part five." />
    <img src="Images/46-push-intro/46-api-subscriptions-six.png"
         alt="ApiSubscriptions part six." />
</div>
<p>
    In the <a href="06-security-protect-api">Secure API</a> lesson, we configured
    two HttpClient services to attach/omit authorization JWTs based on the type of operation
    requested by the Application/Client/ApiServices/ApiManager <a href="09-api-connector-service">
        ApiConnector
    </a> to the Application/Server-Api (e.g., accessor or mutator operation).
</p>
<p>
    The idea was to protect endpoints that allow the application user to modify data in
    any way (e.g., perform POST, PUT, or DELETE operations on the database) and allow
    anonymous (unauthenticated) application users to access controller actions that simply
    retrieve data (GET operations). This is why we had to define specific functionality
    in the IPushSubscriptions interface as opposed to consuming the IRepository&lt;TEntity&gt;
    with general functionality that applies to all data entity types.
</p>
<p>
    <span class="badge bg-dark">6.3</span>
    <span><strong>Ensure that none</strong></span> of the <em>AllocateHttpClient</em> methods
    in the Application/Client/ApiServices/ApiManager ApiConnector class has a hard coded
    <code>JwtOptions</code> option as an argument:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/47-api-connector-jwts.png"
         alt="ApiConnector class with no hard coded Jwt options." />
</div>
<p>
    <span class="badge bg-dark">6.4</span>
    Go to the Application/Client/ApiServices ApiService class and add the IPushSubscriptions
    interface as a read-only property. Ensure it is initialized with a concrete instance of
    the type that serializes/deserializes the Http requests/responses and build the URI to
    the appropriate controller endpoint:
</p>
<div class="image-lesson mb-3">
    <img src="Images/46-push-intro/48-api-service-one.png"
         alt="ApiService class part one." />
    <img src="Images/46-push-intro/49-api-service-two.png"
         alt="ApiService class part two." />
</div>
<p>
    Success! The web server API is ready to handle Http requests/responses for
    PushSubscription operations and the IApiService is successfully enabling
    a communication channel between the Application/Client and the Application/Server-Api.
</p>
<p>Data Sources:</p>
<ul>
    <li>
        "Episode 154. Push API - Backend" of Udemy course
        <a href="https://www.udemy.com/share/101ZK23@FHXR8HROjz7zUmlmb0LdPBR7qBb3ffpRwyKadwoOp833xq3Gp8pRfnTVDJ6xaO9s/">
            Programando en Blazor - ASP.Net Core 7
        </a> by Felipe Gavilán
    </li>
    <li>
        <a href="https://stackoverflow.com/questions/55562371/ef-core-there-is-already-an-object-named-aspnetroles-in-the-database">
            EF Core There is already an object named 'AspNetRoles' in the database.
        </a>
    </li>

    <li>
        <a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-7.0">
            Tutorial: Create a minimal API with ASP.Net Core
        </a>
    </li>
</ul>

